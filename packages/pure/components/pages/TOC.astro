---
import type { MarkdownHeading } from 'astro'

import { generateToc } from '../../plugins/toc'
import TOCHeading from './TOCHeading.astro'

interface Props {
  headings: MarkdownHeading[]
  class?: string
  id?: string
}

const { headings, class: className, ...props } = Astro.props

const toc = generateToc(headings)
---

<toc-heading class={className} {...props}>
  <div class='flex items-center justify-between mb-0 flex-shrink-0'>
    <h2 class='font-medium'>TABLE OF CONTENTS</h2>
    <a
      href='#graph-view'
      class='text-muted-foreground hover:text-foreground transition-colors toc-graph-link'
      title='跳转到图形视图'
      aria-label='跳转到图形视图'
      style='display: none;'
    >
      <svg
        xmlns='http://www.w3.org/2000/svg'
        width='18'
        height='18'
        viewBox='0 0 24 24'
        fill='none'
        stroke='currentColor'
        stroke-width='2'
        stroke-linecap='round'
        stroke-linejoin='round'
      >
        <circle cx='12' cy='12' r='10'></circle>
        <line x1='12' y1='2' x2='12' y2='6'></line>
        <line x1='12' y1='18' x2='12' y2='22'></line>
        <line x1='4.93' y1='4.93' x2='7.76' y2='7.76'></line>
        <line x1='16.24' y1='16.24' x2='19.07' y2='19.07'></line>
        <line x1='2' y1='12' x2='6' y2='12'></line>
        <line x1='18' y1='12' x2='22' y2='12'></line>
        <line x1='4.93' y1='19.07' x2='7.76' y2='16.24'></line>
        <line x1='16.24' y1='7.76' x2='19.07' y2='4.93'></line>
      </svg>
    </a>
  </div>
  <div class='toc-content-wrapper'>
    <ul class='mt-4'>
      {toc.map((heading) => <TOCHeading heading={heading} />)}
    </ul>
  </div>
</toc-heading>

<script>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  interface TOCLink {
    element: HTMLAnchorElement
    progressBar: HTMLElement
    slug: string
  }

  interface HeadingProgress {
    inView: boolean
    progress: number
  }

  class TOC extends HTMLElement {
    headings: HTMLElement[] = []
    tocLinks: TOCLink[] = []
    headingProgress: Record<string, HeadingProgress> = {}

    constructor() {
      super()
      // Initialize the headings and tocLinks
      this.headings = Array.from(
        document.querySelectorAll(
          'article h1, article h2, article h3, article h4, article h5, article h6'
        )
      )
      this.tocLinks = Array.from(this.querySelectorAll('a[href^="#"]')).map((link) => ({
        element: link as HTMLAnchorElement,
        progressBar: link.previousElementSibling as HTMLElement,
        slug: (link.getAttribute('href') || '').substring(1)
      }))
    }

    updatePositionAndStyle = () => {
      const windowHeight = window.innerHeight
      const pageOffset =
        window.scrollY - ((document.querySelector('#content') as HTMLElement)?.offsetTop || 0)
      const postOffset =
        ((document.querySelector('#content') as HTMLElement)?.offsetHeight || 0) + 127

      this.headings.forEach((el, index) => {
        const nextHeadingTop = this.headings[index + 1]?.offsetTop || postOffset
        const range = [el.offsetTop - pageOffset, nextHeadingTop - pageOffset - el.offsetHeight]
        const progress = (windowHeight - range[0]) / (range[1] - range[0])

        this.headingProgress[el.id] = {
          inView: range[0] < windowHeight && range[1] > 0,
          progress: Math.max(0, Math.min(1, progress))
        }
      })

      this.tocLinks.forEach(({ element: el, progressBar: bar, slug }, i) => {
        const { inView, progress } = this.headingProgress[slug]
        if (this.headingProgress[slug]) {
          el.classList.toggle('highlight', inView)
          el.classList.toggle('highlight-bg-translucent', inView)
          el.classList.toggle(
            'rounded-t-2xl',
            inView && (i === 0 || !this.headingProgress[this.tocLinks[i - 1]?.slug].inView)
          )
          el.classList.toggle(
            'rounded-b-2xl',
            inView &&
              (i === this.tocLinks.length - 1 ||
                !this.headingProgress[this.tocLinks[i + 1]?.slug].inView)
          )
          bar.classList.toggle('is-read', !inView && progress === 1)
          bar.classList.toggle('highlight-bg', inView)
          bar.style.setProperty('height', `${progress * 90}%`)
        }
      })
    }

    connectedCallback() {
      // Get graph link element once
      const graphLink = this.querySelector('.toc-graph-link') as HTMLElement
      
      // Check if graph view exists and show/hide the link button
      if (graphLink) {
        const checkGraphView = () => {
          // Check for graph-view or blog-graph-view
          const graphView = document.getElementById('graph-view') || document.getElementById('blog-graph-view')
          if (graphView) {
            graphLink.style.display = 'flex'
          } else {
            graphLink.style.display = 'none'
          }
        }
        
        // Check immediately
        checkGraphView()
        
        // Also check after a delay to catch dynamically loaded graph views
        setTimeout(checkGraphView, 500)
      }

      // Smooth scroll for TOC links
      this.tocLinks.forEach((link) => {
        link.element.addEventListener('click', (e) => {
          e.preventDefault()
          // Push the history to add the hash at the end of the URL
          const directHeading = this.headings.find((heading) => heading.id === link.slug)
          if (directHeading) {
            // Push the history to add the hash at the end of the URL
            history.pushState(
              null,
              directHeading.textContent || '',
              link.element.getAttribute('href')
            )
            directHeading.scrollIntoView({ behavior: 'smooth' })
          } else {
            console.warn(`No heading found for slug: ${link.slug}`)
          }
        })
      })

      // Handle graph view link click
      if (graphLink) {
        graphLink.addEventListener('click', (e) => {
          e.preventDefault()
          
          // Find the target element that GraphView is aligned with
          // Check for outgoing links (相关链接) first
          const outgoingLinks = document.querySelector('.outgoing-links-section')
          // Check for backlinks (反向链接)
          const backlinks = Array.from(document.querySelectorAll('section')).find(
            (section) => 
              section.querySelector('.links-header') && 
              !section.classList.contains('outgoing-links-section')
          ) as HTMLElement
          // Check for Copyright
          const copyrightSection = document.querySelector('.bottom > div:first-child > div.relative') as HTMLElement
          
          let targetElement: HTMLElement | null = null
          
          if (outgoingLinks) {
            // Align with outgoing links (相关链接)
            targetElement = outgoingLinks as HTMLElement
          } else if (backlinks) {
            // Align with backlinks (反向链接)
            targetElement = backlinks
          } else if (copyrightSection) {
            // Align with Copyright
            targetElement = copyrightSection
          }
          
          // Check for graph-view or blog-graph-view
          const graphView = document.getElementById('graph-view') || document.getElementById('blog-graph-view')
          
          if (targetElement) {
            // Scroll to the target element that GraphView is aligned with, with some offset above
            history.pushState(null, 'Graph View', '#graph-view')
            const targetRect = targetElement.getBoundingClientRect()
            const offset = 80 // Offset in pixels above the target element
            const targetPosition = window.scrollY + targetRect.top - offset
            
            window.scrollTo({
              top: Math.max(0, targetPosition),
              behavior: 'smooth'
            })
          } else if (graphView) {
            // Fallback: scroll to graph view itself
            history.pushState(null, 'Graph View', '#graph-view')
            const graphRect = graphView.getBoundingClientRect()
            const offset = 80
            const targetPosition = window.scrollY + graphRect.top - offset
            
            window.scrollTo({
              top: Math.max(0, targetPosition),
              behavior: 'smooth'
            })
          }
        })
      }

      // Initial first and listen to scroll event
      setInterval(this.updatePositionAndStyle, 100)
      window.addEventListener('scroll', this.updatePositionAndStyle)
    }
  }

  customElements.define('toc-heading', TOC)
</script>

<style>
  toc-heading {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    max-height: 100vh;
  }

  toc-heading .toc-content-wrapper {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }

  toc-heading :global(.toc-item) {
    display: flow-root;
  }

  /* Custom scrollbar for TOC content */
  toc-heading .toc-content-wrapper::-webkit-scrollbar {
    width: 5px;
  }

  toc-heading .toc-content-wrapper::-webkit-scrollbar-thumb {
    background-color: hsl(var(--muted-foreground) / 0.3);
    border-radius: 999px;
  }

  toc-heading .toc-content-wrapper {
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--muted-foreground) / 0.3) transparent;
  }
</style>
